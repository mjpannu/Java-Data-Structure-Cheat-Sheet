# Java-Data-Structure-Cheat-Sheet

| **Data Structure** | **Initialization**                   | **Common Methods**                                          | **Example Usage**                         | **Usefulness**                                   |
|--------------------|--------------------------------------|-------------------------------------------------------------|-------------------------------------------|-------------------------------------------------|
| **Array**          | `int[] arr = new int[5];`            | `arr[index]` (Access), `arr[index] = value;` (Modify)       | `arr[0] = 10;`                            | Fixed-size, fast access by index, simple storage |
|                    | `int[] arr = {1, 2, 3};`             |                                                             |                                           |                                                 |
| **ArrayList**      | `ArrayList<Integer> list = new ArrayList<>();` | `list.add(value);` (Add), `list.get(index);` (Access)       | `list.add(5);`                            | Dynamic array, fast random access, resizable     |
|                    |                                      | `list.remove(index);` (Remove)                              | `list.remove(1);`                         |                                                 |
| **LinkedList**     | `LinkedList<String> linkedList = new LinkedList<>();` | `linkedList.add(value);` (Add), `linkedList.get(index);` (Access) | `linkedList.addFirst("Hello");`           | Doubly-linked list, fast insertions/deletions    |
|                    |                                      | `linkedList.remove(index);` (Remove)                        | `linkedList.removeLast();`                | Efficient for frequent insertions/removals       |
| **HashMap**        | `HashMap<String, Integer> map = new HashMap<>();` | `map.put(key, value);` (Add), `map.get(key);` (Access)      | `map.put("A", 1);`                        | Key-value pairs, fast lookup, no duplicate keys  |
|                    |                                      | `map.remove(key);` (Remove)                                 | `map.remove("A");`                        | Ideal for associative arrays, caching            |
| **HashSet**        | `HashSet<String> set = new HashSet<>();` | `set.add(value);` (Add), `set.contains(value);` (Check)     | `set.add("Hello");`                       | Unique elements, fast lookup, no duplicates      |
|                    |                                      | `set.remove(value);` (Remove)                               | `set.remove("Hello");`                    | Great for membership tests, avoiding duplicates  |
| **Stack**          | `Stack<Integer> stack = new Stack<>();` | `stack.push(value);` (Add), `stack.pop();` (Remove)         | `stack.push(10);`                         | LIFO structure, useful for recursive algorithms  |
|                    |                                      | `stack.peek();` (Peek)                                      | `int top = stack.peek();`                 | Parsing expressions, backtracking                |
| **Queue**          | `Queue<Integer> queue = new LinkedList<>();` | `queue.add(value);` (Add), `queue.remove();` (Remove)       | `queue.add(5);`                           | FIFO structure, useful for task scheduling       |
|                    |                                      | `queue.peek();` (Peek)                                      | `int head = queue.peek();`                | Orderly processing, breadth-first search (BFS)   |
| **PriorityQueue**  | `PriorityQueue<Integer> pq = new PriorityQueue<>();` | `pq.add(value);` (Add), `pq.poll();` (Remove)               | `pq.add(10);`                             | Elements ordered by priority, efficient sorting  |
|                    |                                      | `pq.peek();` (Peek)                                         | `int min = pq.peek();`                    | Job scheduling, Dijkstra's algorithm             |
| **TreeSet**        | `TreeSet<Integer> treeSet = new TreeSet<>();` | `treeSet.add(value);` (Add), `treeSet.first();` (Access)    | `treeSet.add(5);`                         | Sorted unique elements, sorted order iteration   |
|                    |                                      | `treeSet.remove(value);` (Remove)                           | `treeSet.remove(5);`                      | Range queries, maintaining sorted sets           |
| **TreeMap**        | `TreeMap<String, Integer> treeMap = new TreeMap<>();` | `treeMap.put(key, value);` (Add), `treeMap.get(key);` (Access) | `treeMap.put("A", 1);`                    | Sorted key-value pairs, natural order iteration  |
|                    |                                      | `treeMap.remove(key);` (Remove)                             | `treeMap.remove("A");`                    | NavigableMap methods, range queries              |
| **LinkedHashMap**  | `LinkedHashMap<String, Integer> lhm = new LinkedHashMap<>();` | `lhm.put(key, value);` (Add), `lhm.get(key);` (Access)      | `lhm.put("A", 1);`                        | Ordered key-value pairs, predictable iteration   |
|                    |                                      | `lhm.remove(key);` (Remove)                                 | `lhm.remove("A");`                        | Caching (LRU), access order tracking             |
| **Deque**          | `Deque<String> deque = new LinkedList<>();` | `deque.addFirst(value);` (Add), `deque.removeLast();` (Remove) | `deque.addFirst("Hello");`                | Double-ended queue, efficient for both ends      |
|                    |                                      | `deque.peekFirst();` (Peek)                                 | `String first = deque.peekFirst();`       | Useful for deque operations, sliding window      |
| **Vector**         | `Vector<Integer> vector = new Vector<>();` | `vector.add(value);` (Add), `vector.get(index);` (Access)   | `vector.add(5);`                          | Thread-safe dynamic array, synchronized methods  |
|                    |                                      | `vector.remove(index);` (Remove)                            | `vector.remove(1);`                       | Legacy, thread safety in single-threaded apps    |
